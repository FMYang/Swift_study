import UIKit

/**
 注意点：
 与oc不同，swift的初始化方法需要保证类型的所有属性都被初始化，所以初始化方法的调用顺序就很讲究。在某个子类中，初始化方法里语句的顺序并不是很随意的，我们需要保证在当前子类实例的成员初始化完成之后才能调用父类的初始化方法。
 
 一般来说，子类的初始化顺序是：
 1、设置子类自己需要的初始化参数
 2、调用父类的初始化方法，super.init()
 3、对父类中的需要改变的成员进行赋值
 
 如果没有第3步，第二部也可以省略，swift会隐身的加上super.init()
 */

/**
 概念：遍历构造器、指定构造器、必要构造器
 
 注意点一：
 1、为UIViewController的子类实现指定构造器，如init(name: String)
 
 方式一：
 使用便利构造器
 
 方式二：
 - 1、实现init(name: String) { super.init(nibName: nil, bundle: nil) } 调用父类的 指定 构造器init(nibName: nil, bundle: nil)
 - 2、重写父类的 必要 构造器required init?(coder: NSCoder)方法
 
 总结：
 继承实现NSCopying协议的类的子类，都必须实现NSCoding协议定义的必要构造器required init?(coder: NSCoder)方法，换句话说子类必须实现父类的必要构造器
 public protocol NSCoding {
     func encode(with coder: NSCoder)
     init?(coder: NSCoder) // NS_DESIGNATED_INITIALIZER
 }
 
 注意点二：
 指定构造器中必须在调用super.init前对所有的存储属性赋值，保证构造过程的完整，子类和父类都能正确完成初始化
 */

/**
 构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例使用前有个过程是必须的，它包括设置实例中每个存储属性的初始值和执行其他必须的设置或构造过程。
 
 1、存储属性的初始赋值：
 类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。
 */

struct Fahrenheit {
    var temperature: Double
    var name: String? // 可选存储属性，不赋值的话默认为nil，表示这个属性在构造过程设置为nil
    init() {
        temperature = 32.0 // 不可选的存储属性必须赋值初始值
    }
}

class A {
    var name: String = ""
}

/**
 2、初始化顺序
 */
class B: A {
    var hairColor: String
    override init() {
        hairColor = "red" // 1、要在父类初始化之前，给存储属性赋值初始值
        super.init() // 2、如果没有对父类的属性赋值，这一步可以省略，系统会自动补上
        name = "new name" // 3、如果对父类的属性赋值了，super.init()不能省略
    }
}

print("======")


/**
 3、类的继承和构造过程：
 
 类里面的所有存储属性，包括所有继承自父类的属性，都必须在构造过程中设置初始值
 
 swift为类提供了两种构造器来确保实例中所有存储属性都能获得初始值，它们被称为指定构造器和遍历构造器
 */

/**
 4、指定构造器和遍历构造器的语法
 */
class T {
    var x = 0
    init() {
        // 指定构造器
    }
    convenience init(_ a: Int) {
        // 遍历构造器
        self.init()
    }
}

/**
 5、类（类类型）的构造器代理
 
 为了简化指定构造器和便利构造器之间的调用关系，swift构造器之间的代理调用遵循以下三条规则：
 
 1、指定构造器必须调用其直接父类的指定构造器
 2、便利构造器必须调用同类中定义的其他构造器
 3、便利构造器最后必须调用指定构造器
 
 一个方便记忆的方法是：
 - 指定构造器总是向上代理
 - 便利构造器总是横向代理
 */

/**
 6、安全检查
 1、指定构造器必须保证它所在的类的所有属性都必须先初始化完成，之后才能将其他构造任务向上代理给父类中的构造器。如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类的属性在它网上代理之前先完成初始化（所以存储属性的赋值要在super.init之前）
 2、指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。（也就是所继承的属性赋值，必须在super.init之后）
 3、便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其他构造器。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。（所以便利构造器的赋值必须在self.init之后）
 4、第一阶段完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。类的实例在第一阶段结束前并不是完全有效的。只有第一阶段完成后，类的实例才是有效的，才能访问属性和方法。
 */

class Animal {
    var eye: Int = 2
    var leg: Int = 2
}

class Dog: Animal {
    var tail: Int
    
    override init() {
        // 第一阶段
        self.tail = 5 // 如果注释掉，报错，不符合规则1，调用super.init之前必须为所有存储属性赋值
//        self.leg = 3 // 报错，不符合规则2、4，第一阶段完成之前不能使用self，super.init之前不能访问父类属性
//        eye = 2 // 报错，不符合规则2，继承的属性必须在super.init之后修改
        super.init() // 第一阶段完成
        // 第二阶段
        self.leg = 4
    }
    
    convenience init(_ b: Int) {
//        leg = 4 // 不符合规则3
        self.init()
        leg = 4 // 符合规则3
    }
}

let dog = Dog()
